<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Parking | Smart City Portal</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
    <style>
        /* General Layout Styles (Consistency) */
        .sidebar {
    min-width: 250px; /* Add this line */
    max-width: 250px; /* Add this line */
    height: 100vh;
    background-color: #2c3e50;
    padding-top: 20px;
    flex-shrink: 0; /* Prevent shrinking */
}
        .sidebar a {
            color: #ecf0f1;
            padding: 15px 20px;
            text-decoration: none;
            display: block;
            border-bottom: 1px solid #34495e;
        }
        .sidebar a:hover, .sidebar .active {
            background-color: #3498db;
            color: white;
        }
        .main-content {
    padding: 30px;
    flex-grow: 1;
    min-width: 0; /* Allow content to shrink if needed */
}
.d-flex {
    overflow: hidden; /* Prevent horizontal scrolling */
}


/* Validation styling */
.is-invalid {
    border-color: #dc3545 !important;
    background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 12 12' width='12' height='12' fill='none' stroke='%23dc3545'%3e%3ccircle cx='6' cy='6' r='4.5'/%3e%3cpath stroke-linejoin='round' d='M5.8 3.6h.4L6 6.5z'/%3e%3ccircle cx='6' cy='8.2' r='.6' fill='%23dc3545' stroke='none'/%3e%3c/svg%3e") !important;
    background-repeat: no-repeat;
    background-position: right calc(0.375em + 0.1875rem) center;
    background-size: calc(0.75em + 0.375rem) calc(0.75em + 0.375rem);
}

.is-invalid:focus {
    box-shadow: 0 0 0 0.25rem rgba(220, 53, 69, 0.25) !important;
}

.invalid-feedback {
    display: none;
    width: 100%;
    margin-top: 0.25rem;
    font-size: 0.875em;
    color: #dc3545;
}

.invalid-feedback.d-block {
    display: block !important;
}


        /* Specific Styles */
        .spot-available { background-color: #d4edda; color: #155724; border-color: #c3e6cb; }
        .spot-reserved { background-color: #fff3cd; color: #856404; border-color: #ffeeba; }
        .spot-occupied { background-color: #f8d7da; color: #721c24; border-color: #f5c6cb; }
        .table-section {
            margin-bottom: 40px;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 20px;
            background-color: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .action-buttons {
            white-space: nowrap;
        }
        .status-badge {
            padding: 4px 8px;
            border-radius: 4px;
            font-weight: 500;
        }
        /* Parking Grid Visualization */
        #parkingGrid {
            min-height: 80px;
        }
    </style>
</head>
<body>

<div class="d-flex">
    <div class="sidebar d-flex flex-column" style="width: 250px;">
        <h4 class="text-white text-center mb-4">Smart City Portal</h4>
        <a href="dashboard.html"><i class="fas fa-th-large me-2"></i> Dashboard</a>
        <a href="traffic.html"><i class="fas fa-car-side me-2"></i> Traffic Management</a>
        <a href="parking.html" class="active"><i class="fas fa-parking me-2"></i> Smart Parking System</a>
        <a href="waste.html"><i class="fas fa-trash-alt me-2"></i> Waste Management</a>
        <a href="energy.html"><i class="fas fa-bolt me-2"></i> Energy Monitoring</a>
        <a href="pollution.html"><i class="fas fa-smog me-2"></i> Air Quality Monitoring</a>
        <a href="emergency.html"><i class="fas fa-ambulance me-2"></i> Emergency Response</a>
        <a href="index.html" class="mt-auto" onclick="sessionStorage.removeItem('userRole');"><i class="fas fa-sign-out-alt me-2"></i> Logout</a>
    </div>

    <div class="main-content flex-grow-1">
        <header class="mb-5 border-bottom pb-3">
            <h1>Smart Parking System</h1>
            <p class="lead text-muted">Manage <strong>Parking Spot Availability</strong> and <strong>Reservations</strong></p>
        </header>

        <section class="mb-5 p-4 border rounded shadow-sm bg-white w-100">
        <h2 class="h4 mb-3"><i class="fas fa-chart-line me-2 text-primary"></i>Weekly Revenue Analytics</h2>
        <div class="w-100" style="height: 300px;">
            <canvas id="parkingChart"></canvas>
        </div>
        <p class="mt-3 text-center text-info">Visual representation of parking revenue over time.</p>
        </section>
        <hr>

        <!-- Table 1 - Reservations -->
        <section class="table-section">
            <h2 class="h4 mb-4"><i class="fas fa-table me-2 text-primary"></i> Table 1 - Reservations</h2>
            
            <div class="d-flex justify-content-between mb-3">
                <div class="input-group" style="width: 350px;">
                    <input type="text" class="form-control" placeholder="Search by Reservation ID or Spot ID" aria-label="Search Reservations" id="searchRes" onkeyup="filterTable('searchRes', 'resBody')">
                    <button class="btn btn-outline-secondary" type="button"><i class="fas fa-search"></i></button>
                </div>

                <button class="btn btn-success" data-bs-toggle="modal" data-bs-target="#addResModal">
                    <i class="fas fa-plus me-1"></i> Add New Reservation
                </button>
            </div>

            <div class="table-responsive">
                <table class="table table-hover align-middle">
                    <thead class="table-light">
                        <tr>
                            <th>Reservation ID</th>
                            <th>Spot ID</th>
                            <th>Citizen ID</th>
                            <th>Citizen Name</th>
                            <th>Start Time</th>
                            <th>End Time</th>
                            <th>Amount ($)</th>  <!-- NEW COLUMN ADDED -->
                            <th>Payment Gateway</th>
                            <th>Payment Date</th>
                            <th>Status</th>
                            <th>Action Buttons</th>
                        </tr>
                    </thead>
                    <tbody id="resBody"></tbody>
                </table>
            </div>
        </section>

        <!-- Table 2 - Parking Spots -->
        <section class="table-section">
            <h2 class="h4 mb-4"><i class="fas fa-parking me-2 text-primary"></i> Table 2 - Parking Spots</h2>
            
            <div class="d-flex justify-content-between mb-3">
                <div class="input-group" style="width: 350px;">
                    <input type="text" class="form-control" placeholder="Search by Spot ID or City" aria-label="Search Parking Spots" id="searchSpot" onkeyup="filterTable('searchSpot', 'spotBody')">
                    <button class="btn btn-outline-secondary" type="button"><i class="fas fa-search"></i></button>
                </div>

                <button class="btn btn-success" data-bs-toggle="modal" data-bs-target="#addSpotModal">
                    <i class="fas fa-plus me-1"></i> Add New Parking Spot
                </button>
            </div>

            <div class="table-responsive">
                <table class="table table-hover align-middle">
                    <thead class="table-light">
                        <tr>
                            <th>Spot ID</th>
                            <th>Road</th>
                            <th>Area</th>
                            <th>City</th>
                            <th>Available Status</th>
                            <th>Parking Lot Capacity</th>
                            <th>Parking Lot ID</th>
                            <th>Action Buttons</th>
                        </tr>
                    </thead>
                    <tbody id="spotBody"></tbody>
                </table>
            </div>
        </section>
    </div>
</div>

<!-- Reservation Modal -->
<div class="modal fade" id="addResModal" tabindex="-1" aria-labelledby="addResModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="addResModalLabel">Add New Reservation</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <form id="addResForm">
                    <div class="mb-3">
                        <label for="addResCitizen" class="form-label">Citizen *</label>
                        <select id="addResCitizen" class="form-select" required></select>
                    </div>
                    <div class="mb-3">
                        <label for="addResSpot" class="form-label">Spot *</label>
                        <select id="addResSpot" class="form-select" required></select>
                    </div>
                    <div class="row">
                        <div class="col-6 mb-3">
                            <label for="addResStart" class="form-label">Start Time *</label>
                            <input type="datetime-local" id="addResStart" class="form-control" required>
                        </div>
                        <div class="col-6 mb-3">
                            <label for="addResEnd" class="form-label">End Time *</label>
                            <input type="datetime-local" id="addResEnd" class="form-control" required>
                        </div>
                    </div>
                    <div class="mb-3">
                        <label for="addResAmount" class="form-label">Amount ($) *</label>
                        <input type="number" step="0.01" id="addResAmount" class="form-control" required>
                    </div>
                    <div class="mb-3">
                        <label for="addResGateway" class="form-label">Payment Gateway *</label>
                        <select id="addResGateway" class="form-select" required>
                            <option value="Credit Card">Credit Card</option>
                            <option value="PayPal">PayPal</option>
                            <option value="Cash">Cash</option>
                        </select>
                    </div>
                    <div class="d-grid gap-2">
                        <button type="submit" class="btn btn-primary">Save Reservation</button>
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    </div>
                </form>
            </div>
        </div>
    </div>
</div>

<!-- Edit Reservation Modal -->
<div class="modal fade" id="editResModal" tabindex="-1" aria-labelledby="editResModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="editResModalLabel">Edit Reservation</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <form id="editResForm">
                    <input type="hidden" id="editResID">
                    <div class="mb-3">
                        <label for="editResCitizen" class="form-label">Citizen *</label>
                        <select id="editResCitizen" class="form-select" required></select>
                    </div>
                    <div class="mb-3">
                        <label for="editResSpot" class="form-label">Spot *</label>
                        <select id="editResSpot" class="form-select" required></select>
                    </div>
                    <div class="row">
                        <div class="col-6 mb-3">
                            <label for="editResStart" class="form-label">Start Time *</label>
                            <input type="datetime-local" id="editResStart" class="form-control" required>
                        </div>
                        <div class="col-6 mb-3">
                            <label for="editResEnd" class="form-label">End Time *</label>
                            <input type="datetime-local" id="editResEnd" class="form-control" required>
                        </div>
                    </div>
                    <div class="mb-3">
                        <label for="editResAmount" class="form-label">Amount ($) *</label>
                        <input type="number" step="0.01" id="editResAmount" class="form-control" required>
                    </div>
                    <div class="mb-3">
                        <label for="editResGateway" class="form-label">Payment Gateway *</label>
                        <select id="editResGateway" class="form-select" required>
                            <option value="Credit Card">Credit Card</option>
                            <option value="PayPal">PayPal</option>
                            <option value="Cash">Cash</option>
                        </select>
                    </div>
                    <div class="d-grid gap-2">
                        <button type="submit" class="btn btn-primary">Update Reservation</button>
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    </div>
                </form>
            </div>
        </div>
    </div>
</div>

<!-- Add Parking Spot Modal -->
<div class="modal fade" id="addSpotModal" tabindex="-1" aria-labelledby="addSpotModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="addSpotModalLabel">Add New Parking Spot</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <form id="addSpotForm">
                    <div class="mb-3">
                        <label for="addSpotID" class="form-label">Spot ID (Optional)</label>
                        <input type="number" id="addSpotID" class="form-control">
                    </div>
                    <div class="mb-3">
                        <label for="addSpotLot" class="form-label">Lot *</label>
                        <select id="addSpotLot" class="form-select" required></select>
                    </div>
                    <div class="mb-3">
                        <label for="addSpotSensor" class="form-label">Sensor *</label>
                        <select id="addSpotSensor" class="form-select" required></select>
                    </div>
                    <div class="mb-3">
                        <label for="addSpotStatus" class="form-label">Status *</label>
                        <select id="addSpotStatus" class="form-select" required>
                            <option value="Available">Available</option>
                            <option value="Occupied">Occupied</option>
                            <option value="Maintenance">Maintenance</option>
                        </select>
                    </div>
                    <div class="d-grid gap-2">
                        <button type="submit" class="btn btn-success">Add Parking Spot</button>
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    </div>
                </form>
            </div>
        </div>
    </div>
</div>

<!-- Edit Parking Spot Modal -->
<div class="modal fade" id="editSpotModal" tabindex="-1" aria-labelledby="editSpotModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="editSpotModalLabel">Edit Parking Spot</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <form id="editSpotForm">
                    <input type="hidden" id="editSpotID_Hidden">
                    <div class="mb-3">
                        <label class="form-label">Spot ID: <span id="editSpotDisplayID" class="fw-bold"></span></label>
                    </div>
                    <div class="mb-3">
                        <label for="editSpotLot" class="form-label">Lot *</label>
                        <select id="editSpotLot" class="form-select" required></select>
                    </div>
                    <div class="mb-3">
                        <label for="editSpotSensor" class="form-label">Sensor *</label>
                        <select id="editSpotSensor" class="form-select" required></select>
                    </div>
                    <div class="mb-3">
                        <label for="editSpotStatus" class="form-label">Status *</label>
                        <select id="editSpotStatus" class="form-select" required>
                            <option value="Available">Available</option>
                            <option value="Occupied">Occupied</option>
                            <option value="Maintenance">Maintenance</option>
                        </select>
                    </div>
                    <div class="d-grid gap-2">
                        <button type="submit" class="btn btn-primary">Update Parking Spot</button>
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    </div>
                </form>
            </div>
        </div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
<script>

        // Add role-based access control
    const userRole = sessionStorage.getItem('userRole') || 'admin'; // Default to admin for testing
    const isCitizen = userRole === 'citizen';
    
        // 1. ROLE-BASED ACCESS CONTROL
    function applyRolePermissions() {
    const userRole = sessionStorage.getItem('userRole') || 'admin'; // Default to admin for testing
    const isCitizen = userRole === 'citizen';
    
    if (isCitizen) {
        // === RESERVATION TABLE (TABLE 1) ===
        // Change "Add New Reservation" button for citizens
        const addResBtn = document.querySelector('[data-bs-target="#addResModal"]');
        if (addResBtn) {
            addResBtn.innerHTML = '<i class="fas fa-plus me-1"></i> Request New Reservation';
            addResBtn.classList.remove('btn-success');
            addResBtn.classList.add('btn-primary');
        }
        
        // Hide "Add New Parking Spot" button completely
        document.querySelector('[data-bs-target="#addSpotModal"]').style.display = 'none';
        
        // Hide Actions column header in Reservations table
        const resTable = document.querySelectorAll('table')[0]; // First table is reservations
        if (resTable) {
            const resHeaders = resTable.querySelectorAll('th');
            resHeaders.forEach(header => {
                if (header.textContent.includes('Action') || header.textContent.includes('Actions')) {
                    header.style.display = 'none';
                }
            });
        }
        
        // === PARKING SPOTS TABLE (TABLE 2) ===
        // Hide Actions column header in Parking Spots table
        const spotTable = document.querySelectorAll('table')[1]; // Second table is parking spots
        if (spotTable) {
            const spotHeaders = spotTable.querySelectorAll('th');
            spotHeaders.forEach(header => {
                if (header.textContent.includes('Action') || header.textContent.includes('Actions')) {
                    header.style.display = 'none';
                }
            });
        }

        // Hide all action buttons in both tables
        document.querySelectorAll('.action-buttons').forEach(cell => {
            cell.style.display = 'none';
        });
        
        // === MODAL PERMISSIONS ===
        // Disable form submissions for citizens (handled individually in form handlers)
        // Note: We're allowing citizens to submit reservation requests, so we handle this in form submission
        
        console.log('Citizen view: Reservation requests enabled, editing disabled');
    } else {
        // Admin view - ensure buttons are visible
        const addResBtn = document.querySelector('[data-bs-target="#addResModal"]');
        if (addResBtn) {
            addResBtn.innerHTML = '<i class="fas fa-plus me-1"></i> Add New Reservation';
            addResBtn.classList.remove('btn-primary');
            addResBtn.classList.add('btn-success');
            addResBtn.style.display = 'block';
        }
        
        const addSpotBtn = document.querySelector('[data-bs-target="#addSpotModal"]');
        if (addSpotBtn) {
            addSpotBtn.style.display = 'block';
        }
        
        // Show Actions column headers
        document.querySelectorAll('th').forEach(header => {
            if (header.style.display === 'none') {
                header.style.display = '';
            }
        });
        
        // Show all action buttons
        document.querySelectorAll('.action-buttons').forEach(cell => {
            cell.style.display = '';
        });
        
        console.log('Admin view: Full CRUD operations enabled');
    }
}

    const API_PATH = 'api/parking';

    document.addEventListener('DOMContentLoaded', () => {
        applyRolePermissions();
        loadDropdowns();
        loadReservations();
        loadSpots();
        loadChart();
    });

    // --- FILTER ---
    function filterTable(inputId, tbodyId) {
        const filter = document.getElementById(inputId).value.toLowerCase();
        const rows = document.getElementById(tbodyId).getElementsByTagName("tr");
        for (let row of rows) {
            row.style.display = row.textContent.toLowerCase().includes(filter) ? "" : "none";
        }
    }

    // --- LOAD RESERVATIONS (TABLE 1) ---
    async function loadReservations() {
    try {
        const res = await fetch(`${API_PATH}/reservations.php`);
        const data = await res.json();
        const tbody = document.getElementById('resBody');
        if(data.error) throw new Error(data.error);

        tbody.innerHTML = data.map(r => {
            // Determine status badge color
            let statusBadgeClass = 'bg-secondary';
            if (r.status === 'Reserved') statusBadgeClass = 'bg-success';
            if (r.status === 'Pending') statusBadgeClass = 'bg-warning';
            
            // Determine action buttons based on role and status
            let actionButtons = '';
            if (!isCitizen) {
                // Admin buttons
                if (r.status === 'Pending') {
                    actionButtons = `
                        <button class="btn btn-sm btn-success me-1" onclick="confirmReservation(${r.reservationID})">
                            <i class="fas fa-check"></i> Confirm
                        </button>
                        <button class="btn btn-sm btn-info text-white me-1" onclick='openEditRes(${JSON.stringify(r)})'>
                            <i class="fas fa-edit"></i> Edit
                        </button>
                        <button class="btn btn-sm btn-danger" onclick="deleteRes(${r.reservationID})">
                            <i class="fas fa-trash-alt"></i> Delete
                        </button>
                    `;
                } else {
                    actionButtons = `
                        <button class="btn btn-sm btn-info text-white me-1" onclick='openEditRes(${JSON.stringify(r)})'>
                            <i class="fas fa-edit"></i> Edit
                        </button>
                        <button class="btn btn-sm btn-danger" onclick="deleteRes(${r.reservationID})">
                            <i class="fas fa-trash-alt"></i> Delete
                        </button>
                    `;
                }
            } else {
                // Citizen - no action buttons
                actionButtons = '<span class="text-muted">No actions</span>';
            }
            
            return `
            <tr>
                <td>${r.reservationID}</td>
                <td>${r.spotID}</td>
                <td>${r.citizenID}</td>
                <td>${r.citizenName}</td>
                <td>${r.startTime}</td>
                <td>${r.endTime}</td>
                <td>$${parseFloat(r.amount).toFixed(2) || '0.00'}</td>
                <td>${r.paymentGateway || '-'}</td>
                <td>${r.paymentDate || '-'}</td>
                <td>
                    <span class="badge ${statusBadgeClass}">${r.status}</span>
                </td>
                <td class="action-buttons">
                    ${actionButtons}
                </td>
            </tr>
            `;
        }).join('');
    } catch(e) { 
        console.error(e); 
    }
}

// Atomic reservation function with retry logic
async function makeAtomicReservation(formData, isCitizen, maxRetries = 3) {
    let retries = 0;
    
    while (retries < maxRetries) {
        try {
            const response = await fetch(`${API_PATH}/reserve_atomic.php`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    ...formData,
                    userRole: isCitizen ? 'Citizen' : 'Admin'
                })
            });
            
            const result = await response.json();
            
            if (result.success) {
                return {
                    success: true,
                    reservationID: result.reservationID,
                    message: result.message,
                    status: result.status
                };
            } else if (result.code === 'DUPLICATE_ENTRY' && retries < maxRetries - 1) {
                // Wait and retry
                retries++;
                const delay = Math.pow(2, retries) * 100; // Exponential backoff
                await new Promise(resolve => setTimeout(resolve, delay));
                continue;
            } else {
                return {
                    success: false,
                    error: result.error || 'Reservation failed',
                    conflicts: result.conflicts
                };
            }
        } catch (error) {
            if (retries < maxRetries - 1) {
                retries++;
                await new Promise(resolve => setTimeout(resolve, 1000));
                continue;
            }
            return {
                success: false,
                error: 'Network error. Please try again.'
            };
        }
    }
}

// Updated form submission
document.getElementById('addResForm').onsubmit = async (e) => {
    e.preventDefault();
    
    // Disable submit button to prevent double-click
    const submitBtn = e.submitter;
    const originalText = submitBtn.innerHTML;
    submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-1"></i> Processing...';
    submitBtn.disabled = true;
    
    try {
        // 1. Client-side validation
        const formData = {
            citizenID: document.getElementById('addResCitizen').value,
            spotID: document.getElementById('addResSpot').value,
            startTime: document.getElementById('addResStart').value,
            endTime: document.getElementById('addResEnd').value,
            amount: document.getElementById('addResAmount').value,
            paymentGateway: document.getElementById('addResGateway').value
        };
        
        const validation = await validateReservationForm(formData, false);
        
        if (!validation.isValid) {
            if (validation.hasDetailedConflict) {
                showConflictDetailsModal(validation.conflictingReservations);
            } else {
                alert(validation.errors.join('\n'));
            }
            return;
        }
        
        // 2. Show warnings if any
        if (validation.warnings.length > 0) {
            if (!confirm(`Warning: ${validation.warnings.join(' ')}\n\nDo you want to proceed?`)) {
                return;
            }
        }
        
        // 3. Make atomic reservation
        const result = await makeAtomicReservation(formData, isCitizen);
        
        if (result.success) {
            bootstrap.Modal.getInstance(document.getElementById('addResModal')).hide();
            loadReservations();
            
            // Show success message
            alert(result.message);
            
            // Clear form
            document.getElementById('addResForm').reset();
        } else {
            if (result.conflicts) {
                showConflictDetailsModal(result.conflicts);
            } else {
                alert(`Reservation failed: ${result.error}`);
            }
        }
        
    } catch (error) {
        console.error('Reservation error:', error);
        alert('An unexpected error occurred. Please try again.');
    } finally {
        // Restore button
        submitBtn.innerHTML = originalText;
        submitBtn.disabled = false;
    }
};

// For edit form (admin only)
document.getElementById('editResForm').onsubmit = async (e) => {
    e.preventDefault();
    
    if (isCitizen) {
        alert('Citizens cannot edit reservations.');
        return;
    }
    
    const submitBtn = e.submitter;
    const originalText = submitBtn.innerHTML;
    submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-1"></i> Updating...';
    submitBtn.disabled = true;
    
    try {
        const reservationID = document.getElementById('editResID').value;
        const formData = {
            citizenID: document.getElementById('editResCitizen').value,
            spotID: document.getElementById('editResSpot').value,
            startTime: document.getElementById('editResStart').value,
            endTime: document.getElementById('editResEnd').value,
            amount: document.getElementById('editResAmount').value,
            paymentGateway: document.getElementById('editResGateway').value
        };
        
        const validation = await validateReservationForm(formData, true, reservationID);
        
        if (!validation.isValid) {
            if (validation.hasDetailedConflict) {
                showConflictDetailsModal(validation.conflictingReservations);
            } else {
                alert(validation.errors.join('\n'));
            }
            return;
        }
        
        // Use the original update endpoint for edits (not atomic, since we're modifying existing)
        const result = await apiCall(`${API_PATH}/reservations.php`, 'PUT', {
            reservationID: reservationID,
            ...formData
        });
        
        if (result && !result.error) {
            bootstrap.Modal.getInstance(document.getElementById('editResModal')).hide();
            loadReservations();
            alert('Reservation updated successfully!');
        }
        
    } finally {
        submitBtn.innerHTML = originalText;
        submitBtn.disabled = false;
    }
};


// Optimistic UI update (makes app feel faster)
function optimisticReservationAdd(formData, status) {
    const tbody = document.getElementById('resBody');
    const now = new Date().toISOString().slice(0, 19).replace('T', ' ');
    
    const tempRow = document.createElement('tr');
    tempRow.id = 'temp-reservation';
    tempRow.innerHTML = `
        <td><i class="fas fa-spinner fa-spin me-1"></i>Processing...</td>
        <td>${formData.spotID}</td>
        <td>${formData.citizenID}</td>
        <td>Loading...</td>
        <td>${formData.startTime.replace('T', ' ')}</td>
        <td>${formData.endTime.replace('T', ' ')}</td>
        <td>$${parseFloat(formData.amount).toFixed(2)}</td>
        <td>${formData.paymentGateway}</td>
        <td>${now}</td>
        <td><span class="badge bg-secondary">Processing</span></td>
        <td class="action-buttons">
            <span class="text-muted">Processing...</span>
        </td>
    `;
    
    // Add at the top of the table
    if (tbody.firstChild) {
        tbody.insertBefore(tempRow, tbody.firstChild);
    } else {
        tbody.appendChild(tempRow);
    }
    
    // Scroll to show the new reservation
    tempRow.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
}

// Remove optimistic update when done
function removeOptimisticUpdate() {
    const tempRow = document.getElementById('temp-reservation');
    if (tempRow) {
        tempRow.remove();
    }
}

// Update your atomic reservation function:
async function makeAtomicReservation(formData, isCitizen, maxRetries = 3) {
    // Show optimistic update
    optimisticReservationAdd(formData, isCitizen ? 'Pending' : 'Reserved');
    
    let retries = 0;
    
    try {
        // ... existing atomic reservation code ...
        
        if (result.success) {
            removeOptimisticUpdate();
            return {
                success: true,
                reservationID: result.reservationID,
                message: result.message,
                status: result.status
            };
        } else {
            removeOptimisticUpdate();
            return {
                success: false,
                error: result.error || 'Reservation failed',
                conflicts: result.conflicts
            };
        }
    } catch (error) {
        removeOptimisticUpdate();
        return {
            success: false,
            error: 'Network error. Please try again.'
        };
    }
}

// New function to confirm a reservation
async function confirmReservation(reservationID) {
    if (isCitizen) {
        alert('Citizens cannot confirm reservations.');
        return;
    }
    
    if (confirm('Are you sure you want to confirm this reservation?')) {
        try {
            const response = await fetch(`${API_PATH}/reservations.php`, {
                method: 'PUT',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    reservationID: reservationID,
                    newStatus: 'Reserved'
                })
            });
            
            const result = await response.json();
            if (result.message) {
                alert('Reservation confirmed successfully!');
                loadReservations();
            } else if (result.error) {
                alert('Error: ' + result.error);
            }
        } catch (error) {
            console.error('Error confirming reservation:', error);
            alert('Error confirming reservation.');
        }
    }
}

// Real-time validation for datetime inputs
function setupRealTimeValidation() {
    const startTimeInput = document.getElementById('addResStart');
    const endTimeInput = document.getElementById('addResEnd');
    const editStartTimeInput = document.getElementById('editResStart');
    const editEndTimeInput = document.getElementById('editResEnd');
    
    // Add validation for Add Reservation form
    if (startTimeInput && endTimeInput) {
        startTimeInput.addEventListener('change', function() {
            validateDateTimeInputs(this, endTimeInput, 'add');
        });
        
        endTimeInput.addEventListener('change', function() {
            validateDateTimeInputs(startTimeInput, this, 'add');
        });
    }
    
    // Add validation for Edit Reservation form
    if (editStartTimeInput && editEndTimeInput) {
        editStartTimeInput.addEventListener('change', function() {
            validateDateTimeInputs(this, editEndTimeInput, 'edit');
        });
        
        editEndTimeInput.addEventListener('change', function() {
            validateDateTimeInputs(editStartTimeInput, this, 'edit');
        });
    }
}

function validateDateTimeInputs(startInput, endInput, formType) {
    const startTime = startInput.value;
    const endTime = endInput.value;
    
    if (!startTime || !endTime) return;
    
    const currentTime = new Date();
    const selectedStartTime = new Date(startTime);
    const selectedEndTime = new Date(endTime);
    
    // Reset any previous error styling
    startInput.classList.remove('is-invalid');
    endInput.classList.remove('is-invalid');
    
    // Check if start time is in the past
    if (selectedStartTime < currentTime) {
        startInput.classList.add('is-invalid');
        showTooltip(startInput, 'Start time cannot be in the past');
        return false;
    }
    
    // Check if end time is before start time
    if (selectedEndTime <= selectedStartTime) {
        endInput.classList.add('is-invalid');
        showTooltip(endInput, 'End time must be after start time');
        return false;
    }
    
    return true;
}

function showTooltip(input, message) {
    // Remove existing tooltip
    const existingTooltip = input.parentElement.querySelector('.invalid-feedback');
    if (existingTooltip) {
        existingTooltip.remove();
    }
    
    // Create new tooltip
    const tooltip = document.createElement('div');
    tooltip.className = 'invalid-feedback d-block';
    tooltip.textContent = message;
    input.parentElement.appendChild(tooltip);
    
    // Auto-remove after 5 seconds
    setTimeout(() => {
        if (tooltip.parentElement) {
            tooltip.remove();
            input.classList.remove('is-invalid');
        }
    }, 5000);
}

// Call this in DOMContentLoaded
document.addEventListener('DOMContentLoaded', () => {
    applyRolePermissions();
    loadDropdowns();
    loadReservations();
    loadSpots();
    loadChart();
    setupRealTimeValidation(); // Add this line
});

// Updated conflict checking function with detailed conflict information
async function checkReservationConflict(spotID, startTime, endTime, excludeReservationID = null) {
    try {
        const response = await fetch(`${API_PATH}/check_conflict.php`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                spotID: spotID,
                startTime: startTime,
                endTime: endTime,
                excludeReservationID: excludeReservationID
            })
        });
        
        const result = await response.json();
        
        if (result.hasConflict && result.conflictingReservations) {
            // We already have conflict details from the API
            return {
                hasConflict: true,
                conflictingDetails: result.conflictingReservations
            };
        }
        
        // Fallback: Fetch details manually if API didn't provide them
        if (result.hasConflict) {
            try {
                const res = await fetch(`${API_PATH}/reservations.php`);
                const allReservations = await res.json();
                
                // Find reservations for the same spot
                const spotReservations = allReservations.filter(r => 
                    r.spotID == spotID && 
                    r.reservationID != excludeReservationID
                );
                
                // Check for time overlaps manually
                const newStart = new Date(startTime);
                const newEnd = new Date(endTime);
                
                const conflicts = spotReservations.filter(r => {
                    const existingStart = new Date(r.startTime);
                    const existingEnd = new Date(r.endTime);
                    
                    // Check for overlap: NOT (new ends before existing starts OR new starts after existing ends)
                    return !(newEnd <= existingStart || newStart >= existingEnd);
                });
                
                if (conflicts.length > 0) {
                    return {
                        hasConflict: true,
                        conflictingDetails: conflicts
                    };
                }
            } catch (e) {
                console.error('Error fetching conflict details:', e);
            }
            
            return {
                hasConflict: true,
                conflictingDetails: []
            };
        }
        
        return { hasConflict: false, conflictingDetails: [] };
        
    } catch (error) {
        console.error('Error checking reservation conflicts:', error);
        return { hasConflict: false, conflictingDetails: [] };
    }
}
    
    // --- LOAD SPOTS (TABLE 2) ---
    async function loadSpots() {
        try {
            const res = await fetch(`${API_PATH}/spots.php`);
            const data = await res.json();
            const tbody = document.getElementById('spotBody');
            
            tbody.innerHTML = data.map(s => {
                const badgeClass = s.status === 'Available' ? 'bg-success' : 
                                 s.status === 'Occupied' ? 'bg-danger' : 'bg-secondary';
                
                return `
                <tr>
                    <td><strong>${s.spotID}</strong></td>
                    <td>${s.road || '-'}</td>
                    <td>${s.area || '-'}</td>
                    <td>${s.city || '-'}</td>
                    <td><span class="badge ${badgeClass}">${s.status}</span></td>
                    <td>${s.capacity || '-'}</td>
                    <td>${s.lotID}</td>
                    <td class="action-buttons">
                        <button class="btn btn-sm btn-info text-white me-1" onclick='openEditSpot(${JSON.stringify(s)})'><i class="fas fa-edit"></i> Edit</button>
                        <button class="btn btn-sm btn-danger" onclick="deleteSpot(${s.spotID})"><i class="fas fa-trash-alt"></i> Delete</button>
                    </td>
                </tr>
                `;
            }).join('');
        } catch(e) { console.error(e); }
        applyRolePermissions();
    }

    // --- ADD/EDIT ACTIONS ---
   
// --- ADD RESERVATION FORM ---
document.getElementById('addResForm').onsubmit = async (e) => {
    e.preventDefault();
    
    // Get form values
    const spotID = document.getElementById('addResSpot').value;
    const startTime = document.getElementById('addResStart').value;
    const endTime = document.getElementById('addResEnd').value;
    const citizenID = document.getElementById('addResCitizen').value;
    const amount = document.getElementById('addResAmount').value;
    
    // --- VALIDATION 1: Start time cannot be in the past ---
    const currentTime = new Date();
    const selectedStartTime = new Date(startTime);
    
    if (selectedStartTime < currentTime) {
        alert('Error: Start time cannot be in the past. Please select a future date and time.');
        return;
    }
    
    // --- VALIDATION 2: End time cannot be before start time ---
    const selectedEndTime = new Date(endTime);
    if (selectedEndTime <= selectedStartTime) {
        alert('Error: End time must be after start time.');
        return;
    }
    
    // --- VALIDATION 3: Check for overlapping reservations ---
    const conflictCheck = await checkReservationConflict(spotID, startTime, endTime);
    if (conflictCheck.hasConflict) {
        // Build detailed error message
        let errorMessage = 'Error: This parking spot is already booked during your selected time period.\n\n';
        
        if (conflictCheck.conflictingDetails && conflictCheck.conflictingDetails.length > 0) {
            errorMessage += 'Conflicting reservations:\n';
            conflictCheck.conflictingDetails.forEach((conflict, index) => {
                errorMessage += `${index + 1}. Reservation #${conflict.reservationID}:\n`;
                errorMessage += `   Time: ${conflict.startTime} to ${conflict.endTime}\n`;
                errorMessage += `   Status: ${conflict.status}\n`;
                errorMessage += `   Booked by: ${conflict.citizenName || 'N/A'}\n\n`;
            });
        } else {
            errorMessage += 'The selected time period overlaps with an existing reservation.';
        }
        
        alert(errorMessage);
        return;
    }
    
    // --- Additional validation: Amount must be positive ---
    if (parseFloat(amount) <= 0) {
        alert('Error: Amount must be greater than 0.');
        return;
    }
    
    // All validations passed, submit the form
    const requestData = {
        citizenID: citizenID,
        spotID: spotID,
        startTime: startTime,
        endTime: endTime,
        amount: amount,
        paymentGateway: document.getElementById('addResGateway').value,
        userRole: isCitizen ? 'Citizen' : 'Admin'
    };
    
    const result = await apiCall(`${API_PATH}/reservations.php`, 'POST', requestData);
    
    if (result && !result.error) {
        bootstrap.Modal.getInstance(document.getElementById('addResModal')).hide();
        loadReservations();
        
        // Show appropriate message
        const message = isCitizen 
            ? 'Your reservation request has been submitted and is pending approval.'
            : 'Reservation created successfully!';
        alert(message);
    }
};

// --- EDIT RESERVATION FORM ---
document.getElementById('editResForm').onsubmit = async (e) => {
    e.preventDefault();
    
    if (isCitizen) {
        alert('Citizens cannot edit reservations.');
        return;
    }
    
    // Get form values
    const reservationID = document.getElementById('editResID').value;
    const spotID = document.getElementById('editResSpot').value;
    const startTime = document.getElementById('editResStart').value;
    const endTime = document.getElementById('editResEnd').value;
    const amount = document.getElementById('editResAmount').value;
    
    // --- VALIDATION 1: Start time cannot be in the past ---
    const currentTime = new Date();
    const selectedStartTime = new Date(startTime);
    
    // For editing, we need to check if it's being changed to a past time
    // First, get the original reservation to check
    try {
        const res = await fetch(`${API_PATH}/reservations.php`);
        const allReservations = await res.json();
        const originalReservation = allReservations.find(r => r.reservationID == reservationID);
        
        // If start time is being changed AND new time is in the past, show error
        if (originalReservation && new Date(originalReservation.startTime).getTime() !== selectedStartTime.getTime()) {
            if (selectedStartTime < currentTime) {
                alert('Error: Start time cannot be changed to a past time.');
                return;
            }
        }
    } catch (error) {
        console.error('Error checking original reservation:', error);
    }
    
    // --- VALIDATION 2: End time cannot be before start time ---
    const selectedEndTime = new Date(endTime);
    if (selectedEndTime <= selectedStartTime) {
        alert('Error: End time must be after start time.');
        return;
    }
    
    // --- VALIDATION 3: Check for overlapping reservations (excluding current one) ---
    const conflictCheck = await checkReservationConflict(spotID, startTime, endTime, reservationID);
    if (conflictCheck.hasConflict) {
        // Build detailed error message
        let errorMessage = 'Error: This parking spot is already booked during your selected time period.\n\n';
        
        if (conflictCheck.conflictingDetails && conflictCheck.conflictingDetails.length > 0) {
            errorMessage += 'Conflicting reservations:\n';
            conflictCheck.conflictingDetails.forEach((conflict, index) => {
                errorMessage += `${index + 1}. Reservation #${conflict.reservationID}:\n`;
                errorMessage += `   Time: ${conflict.startTime} to ${conflict.endTime}\n`;
                errorMessage += `   Status: ${conflict.status}\n`;
                errorMessage += `   Booked by: ${conflict.citizenName || 'N/A'}\n\n`;
            });
        } else {
            errorMessage += 'The selected time period overlaps with an existing reservation.';
        }
        
        alert(errorMessage);
        return;
    }
    
    // --- Additional validation: Amount must be positive ---
    if (parseFloat(amount) <= 0) {
        alert('Error: Amount must be greater than 0.');
        return;
    }
    
    // All validations passed, submit the form
    const result = await apiCall(`${API_PATH}/reservations.php`, 'PUT', {
        reservationID: reservationID,
        citizenID: document.getElementById('editResCitizen').value,
        spotID: spotID,
        startTime: startTime,
        endTime: endTime,
        amount: amount,
        paymentGateway: document.getElementById('editResGateway').value
    });
    
    if (result && !result.error) {
        bootstrap.Modal.getInstance(document.getElementById('editResModal')).hide();
        loadReservations();
        alert('Reservation updated successfully!');
    }
};
    // Reservations - Edit form with validation
document.getElementById('editResForm').onsubmit = async (e) => {
    e.preventDefault();
    
    if (isCitizen) {
        alert('Citizens cannot edit reservations.');
        return;
    }
    
    // Get form values
    const reservationID = document.getElementById('editResID').value;
    const spotID = document.getElementById('editResSpot').value;
    const startTime = document.getElementById('editResStart').value;
    const endTime = document.getElementById('editResEnd').value;
    
    // Validate start time is before end time
    if (new Date(startTime) >= new Date(endTime)) {
        alert('Error: Start time must be before end time.');
        return;
    }
    
    // Check for reservation conflicts (excluding current reservation)
    const conflictCheck = await checkReservationConflict(spotID, startTime, endTime, reservationID);
    if (conflictCheck.hasConflict) {
        alert(`Error: ${conflictCheck.message}`);
        return;
    }
    
    await apiCall(`${API_PATH}/reservations.php`, 'PUT', {
        reservationID: reservationID,
        citizenID: document.getElementById('editResCitizen').value,
        spotID: spotID,
        startTime: startTime,
        endTime: endTime,
        amount: document.getElementById('editResAmount').value,
        paymentGateway: document.getElementById('editResGateway').value
    });
    bootstrap.Modal.getInstance(document.getElementById('editResModal')).hide();
    loadReservations();
};
    
    // Spots - Add form
    document.getElementById('addSpotForm').onsubmit = async (e) => {
        e.preventDefault();
        
        if (isCitizen) {
            alert('Citizens cannot add parking spots.');
            return;
        }
        
        await apiCall(`${API_PATH}/spots.php`, 'POST', {
            spotID: document.getElementById('addSpotID').value,
            lotID: document.getElementById('addSpotLot').value,
            sensorID: document.getElementById('addSpotSensor').value,
            status: document.getElementById('addSpotStatus').value
        });
        bootstrap.Modal.getInstance(document.getElementById('addSpotModal')).hide();
        loadSpots();
    };

    // Spots - Edit form
    document.getElementById('editSpotForm').onsubmit = async (e) => {
        e.preventDefault();
        
        if (isCitizen) {
            alert('Citizens cannot edit parking spots.');
            return;
        }
        
        await apiCall(`${API_PATH}/spots.php`, 'PUT', {
            spotID: document.getElementById('editSpotID_Hidden').value,
            lotID: document.getElementById('editSpotLot').value,
            sensorID: document.getElementById('editSpotSensor').value,
            status: document.getElementById('editSpotStatus').value
        });
        bootstrap.Modal.getInstance(document.getElementById('editSpotModal')).hide();
        loadSpots();
    };

    document.getElementById('editResForm').onsubmit = async (e) => {
        e.preventDefault();
        await apiCall(`${API_PATH}/reservations.php`, 'PUT', {
            reservationID: document.getElementById('editResID').value,
            citizenID: document.getElementById('editResCitizen').value,
            spotID: document.getElementById('editResSpot').value,
            startTime: document.getElementById('editResStart').value,
            endTime: document.getElementById('editResEnd').value,
            amount: document.getElementById('editResAmount').value,
            paymentGateway: document.getElementById('editResGateway').value
        });
        bootstrap.Modal.getInstance(document.getElementById('editResModal')).hide();
        loadReservations();
    };

    // Spots
    document.getElementById('addSpotForm').onsubmit = async (e) => {
        e.preventDefault();
        await apiCall(`${API_PATH}/spots.php`, 'POST', {
            spotID: document.getElementById('addSpotID').value,
            lotID: document.getElementById('addSpotLot').value,
            sensorID: document.getElementById('addSpotSensor').value,
            status: document.getElementById('addSpotStatus').value
        });
        bootstrap.Modal.getInstance(document.getElementById('addSpotModal')).hide();
        loadSpots();
    };

    document.getElementById('editSpotForm').onsubmit = async (e) => {
        e.preventDefault();
        await apiCall(`${API_PATH}/spots.php`, 'PUT', {
            spotID: document.getElementById('editSpotID_Hidden').value,
            lotID: document.getElementById('editSpotLot').value,
            sensorID: document.getElementById('editSpotSensor').value,
            status: document.getElementById('editSpotStatus').value
        });
        bootstrap.Modal.getInstance(document.getElementById('editSpotModal')).hide();
        loadSpots();
    };

    // --- HELPERS ---
        window.openEditRes = (r) => {
        if (isCitizen) {
            alert('Citizens cannot edit reservations.');
            return;
        }
        document.getElementById('editResID').value = r.reservationID;
        document.getElementById('editResCitizen').value = r.citizenID;
        document.getElementById('editResSpot').value = r.spotID;
        document.getElementById('editResStart').value = r.startTime ? r.startTime.replace(' ', 'T') : '';
        document.getElementById('editResEnd').value = r.endTime ? r.endTime.replace(' ', 'T') : '';
        document.getElementById('editResAmount').value = r.amount;
        document.getElementById('editResGateway').value = r.paymentGateway || 'Credit Card';
        new bootstrap.Modal(document.getElementById('editResModal')).show();
    };

    window.openEditSpot = (s) => {
        if (isCitizen) {
            alert('Citizens cannot edit parking spots.');
            return;
        }
        document.getElementById('editSpotID_Hidden').value = s.spotID;
        document.getElementById('editSpotDisplayID').innerText = s.spotID;
        document.getElementById('editSpotLot').value = s.lotID;
        document.getElementById('editSpotSensor').value = s.sensorID;
        document.getElementById('editSpotStatus').value = s.status || 'Available';
        new bootstrap.Modal(document.getElementById('editSpotModal')).show();
    };

    window.openEditSpot = (s) => {
        document.getElementById('editSpotID_Hidden').value = s.spotID;
        document.getElementById('editSpotDisplayID').innerText = s.spotID;
        document.getElementById('editSpotLot').value = s.lotID;
        document.getElementById('editSpotSensor').value = s.sensorID;
        document.getElementById('editSpotStatus').value = s.status || 'Available';
        new bootstrap.Modal(document.getElementById('editSpotModal')).show();
    };

        window.deleteRes = async (id) => { 
        if (isCitizen) {
            alert('Citizens cannot cancel reservations.');
            return;
        }
        if(confirm('Are you sure you want to cancel this reservation?')) { 
            await apiCall(`${API_PATH}/reservations.php?id=${id}`, 'DELETE'); 
            loadReservations(); 
        } 
    };
    
    window.deleteSpot = async (id) => { 
        if (isCitizen) {
            alert('Citizens cannot delete parking spots.');
            return;
        }
        if(confirm('Are you sure you want to delete this parking spot? This action cannot be undone.')) { 
            await apiCall(`${API_PATH}/spots.php?id=${id}`, 'DELETE'); 
            loadSpots(); 
        } 
    };
    
    window.deleteSpot = async (id) => { 
        if(confirm('Are you sure you want to delete this parking spot? This action cannot be undone.')) { 
            await apiCall(`${API_PATH}/spots.php?id=${id}`, 'DELETE'); 
            loadSpots();
        } 
    };

    // Enhanced conflict checking with detailed messages
async function checkReservationWithDetails(spotID, startTime, endTime, excludeReservationID = null) {
    try {
        const response = await fetch(`${API_PATH}/check_conflict.php`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                spotID: spotID,
                startTime: startTime,
                endTime: endTime,
                excludeReservationID: excludeReservationID
            })
        });
        
        const result = await response.json();
        
        if (result.error) {
            return {
                hasConflict: true,
                errorType: 'system',
                message: result.error,
                conflictingDetails: []
            };
        }
        
        if (result.hasConflict) {
            let message = '';
            
            // Custom messages based on error type
            if (result.errorType === 'duration') {
                message = result.message;
            } else if (result.errorType === 'max_duration') {
                message = result.message;
            } else if (result.conflictingReservations && result.conflictingReservations.length > 0) {
                // Time overlap conflicts
                message = `Parking spot is already booked during your selected time.\n\n`;
                message += `Conflicting reservation(s):\n`;
                
                result.conflictingReservations.forEach((conflict, index) => {
                    const start = new Date(conflict.startTime).toLocaleString();
                    const end = new Date(conflict.endTime).toLocaleString();
                    message += `${index + 1}. Reservation #${conflict.reservationID}\n`;
                    message += `   Booked by: ${conflict.citizenName}\n`;
                    message += `   Time: ${start} to ${end}\n`;
                    message += `   Status: ${conflict.status}\n\n`;
                });
            } else {
                message = 'Time slot is not available for this parking spot.';
            }
            
            return {
                hasConflict: true,
                errorType: result.errorType || 'time_conflict',
                message: message,
                conflictingDetails: result.conflictingReservations || [],
                spotStatus: result.spotStatus
            };
        }
        
        return {
            hasConflict: false,
            spotStatus: result.spotStatus
        };
        
    } catch (error) {
        console.error('Error checking reservation conflicts:', error);
        return {
            hasConflict: true,
            errorType: 'network',
            message: 'Spot is not available at that time and date. Please try different time and date',
            conflictingDetails: []
        };
    }
}

// Unified validation function for reservation forms
async function validateReservationForm(spotID, startTime, endTime, amount, isEdit = false, reservationID = null) {
    const errors = [];
    const warnings = [];
    
    // 1. Basic validation
    if (!spotID) errors.push('Please select a parking spot.');
    if (!startTime) errors.push('Start time is required.');
    if (!endTime) errors.push('End time is required.');
    if (!amount || parseFloat(amount) <= 0) errors.push('Amount must be greater than 0.');
    
    if (errors.length > 0) {
        return { isValid: false, errors: errors };
    }
    
    // 2. Date/time validation
    const now = new Date();
    const start = new Date(startTime);
    const end = new Date(endTime);
    
    // For new reservations, check start time is not in past
    if (!isEdit && start < now) {
        errors.push('Start time cannot be in the past.');
    }
    
    // Check end time is after start time
    if (end <= start) {
        errors.push('End time must be after start time.');
    }
    
    if (errors.length > 0) {
        return { isValid: false, errors: errors };
    }
    
    // 3. Advanced conflict checking
    const conflictCheck = await checkReservationWithDetails(spotID, startTime, endTime, reservationID);
    
    if (conflictCheck.hasConflict) {
        if (conflictCheck.errorType === 'time_conflict' && conflictCheck.conflictingDetails.length > 0) {
            // Show detailed conflict information
            return {
                isValid: false,
                errors: [conflictCheck.message],
                hasDetailedConflict: true,
                conflictingReservations: conflictCheck.conflictingDetails
            };
        } else {
            return {
                isValid: false,
                errors: [conflictCheck.message]
            };
        }
    }
    
    // 4. Check spot status
    if (conflictCheck.spotStatus === 'Maintenance') {
        warnings.push('This parking spot is currently under maintenance.');
    } else if (conflictCheck.spotStatus === 'Occupied') {
        warnings.push('This parking spot is currently occupied.');
    }
    
    return {
        isValid: true,
        warnings: warnings,
        spotStatus: conflictCheck.spotStatus
    };
}

// Update your form submission handlers
async function handleReservationFormSubmit(formData, isEdit = false, reservationID = null) {
    // Show loading state
    const submitBtn = event.submitter;
    const originalText = submitBtn.innerHTML;
    submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-1"></i> Checking Availability...';
    submitBtn.disabled = true;
    
    try {
        const validation = await validateReservationForm(
            formData.spotID,
            formData.startTime,
            formData.endTime,
            formData.amount,
            isEdit,
            reservationID
        );
        
        if (!validation.isValid) {
            // Show detailed conflict modal if available
            if (validation.hasDetailedConflict) {
                showConflictDetailsModal(validation.conflictingReservations);
            } else {
                alert(validation.errors.join('\n'));
            }
            return false;
        }
        
        // Show warnings if any
        if (validation.warnings.length > 0) {
            if (!confirm(`Warning: ${validation.warnings.join(' ')}\n\nDo you want to proceed?`)) {
                return false;
            }
        }
        
        return true;
        
    } finally {
        // Restore button state
        submitBtn.innerHTML = originalText;
        submitBtn.disabled = false;
    }
}

// Function to show detailed conflict information in a modal
function showConflictDetailsModal(conflicts) {
    let conflictHtml = `
        <div class="modal fade" id="conflictDetailsModal" tabindex="-1">
            <div class="modal-dialog modal-lg">
                <div class="modal-content">
                    <div class="modal-header bg-warning">
                        <h5 class="modal-title"><i class="fas fa-exclamation-triangle me-2"></i>Time Slot Conflict</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                    </div>
                    <div class="modal-body">
                        <p>The parking spot is already booked during your selected time.</p>
                        <div class="table-responsive">
                            <table class="table table-sm">
                                <thead>
                                    <tr>
                                        <th>Reservation ID</th>
                                        <th>Booked By</th>
                                        <th>Start Time</th>
                                        <th>End Time</th>
                                        <th>Status</th>
                                    </tr>
                                </thead>
                                <tbody>`;
    
    conflicts.forEach(conflict => {
        const start = new Date(conflict.startTime).toLocaleString();
        const end = new Date(conflict.endTime).toLocaleString();
        conflictHtml += `
            <tr>
                <td>#${conflict.reservationID}</td>
                <td>${conflict.citizenName}</td>
                <td>${start}</td>
                <td>${end}</td>
                <td><span class="badge ${conflict.status === 'Reserved' ? 'bg-success' : 'bg-warning'}">${conflict.status}</span></td>
            </tr>`;
    });
    
    conflictHtml += `
                                </tbody>
                            </table>
                        </div>
                        <div class="alert alert-info mt-3">
                            <i class="fas fa-info-circle me-2"></i>
                            Please select a different time slot or choose another parking spot.
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                    </div>
                </div>
            </div>
        </div>`;
    
    // Add modal to DOM if not already present
    if (!document.getElementById('conflictDetailsModal')) {
        document.body.insertAdjacentHTML('beforeend', conflictHtml);
    }
    
    // Show the modal
    const modal = new bootstrap.Modal(document.getElementById('conflictDetailsModal'));
    modal.show();
}

// Update your existing form submission handlers
document.getElementById('addResForm').onsubmit = async (e) => {
    e.preventDefault();
    
    const formData = {
        citizenID: document.getElementById('addResCitizen').value,
        spotID: document.getElementById('addResSpot').value,
        startTime: document.getElementById('addResStart').value,
        endTime: document.getElementById('addResEnd').value,
        amount: document.getElementById('addResAmount').value,
        paymentGateway: document.getElementById('addResGateway').value
    };
    
    // Use the new validation
    const isValid = await handleReservationFormSubmit(formData, false);
    
    if (!isValid) {
        return;
    }
    
    // If validation passes, proceed with API call
    const result = await apiCall(`${API_PATH}/reservations.php`, 'POST', {
        ...formData,
        userRole: isCitizen ? 'Citizen' : 'Admin'
    });
    
    if (result && !result.error) {
        bootstrap.Modal.getInstance(document.getElementById('addResModal')).hide();
        loadReservations();
        
        const message = isCitizen 
            ? 'Your reservation request has been submitted and is pending approval.'
            : 'Reservation created successfully!';
        alert(message);
    }
};

document.getElementById('editResForm').onsubmit = async (e) => {
    e.preventDefault();
    
    if (isCitizen) {
        alert('Citizens cannot edit reservations.');
        return;
    }
    
    const reservationID = document.getElementById('editResID').value;
    const formData = {
        citizenID: document.getElementById('editResCitizen').value,
        spotID: document.getElementById('editResSpot').value,
        startTime: document.getElementById('editResStart').value,
        endTime: document.getElementById('editResEnd').value,
        amount: document.getElementById('editResAmount').value,
        paymentGateway: document.getElementById('editResGateway').value
    };
    
    // Use the new validation
    const isValid = await handleReservationFormSubmit(formData, true, reservationID);
    
    if (!isValid) {
        return;
    }
    
    // If validation passes, proceed with API call
    const result = await apiCall(`${API_PATH}/reservations.php`, 'PUT', {
        reservationID: reservationID,
        ...formData
    });
    
    if (result && !result.error) {
        bootstrap.Modal.getInstance(document.getElementById('editResModal')).hide();
        loadReservations();
        alert('Reservation updated successfully!');
    }
};



    async function apiCall(url, method, body) {
    // Add user role to all requests
    if (body) {
        body.userRole = isCitizen ? 'Citizen' : 'Admin';
    }
    
    const res = await fetch(url, { 
        method: method, 
        headers: {'Content-Type': 'application/json'}, 
        body: JSON.stringify(body) 
    });
    const json = await res.json();
    if(json.error) alert(json.error);
    return json;
}

    async function checkReservationConflict(spotID, startTime, endTime, excludeReservationID = null) {
    try {
        // Fetch all reservations for the specific spot
        const res = await fetch(`${API_PATH}/reservations.php`);
        const reservations = await res.json();
        
        const newStart = new Date(startTime);
        const newEnd = new Date(endTime);
        
        // Check each existing reservation for the same spot
        for (const reservation of reservations) {
            // Skip the reservation being edited
            if (excludeReservationID && reservation.reservationID == excludeReservationID) {
                continue;
            }
            
            // Only check reservations for the same spot
            if (reservation.spotID == spotID) {
                const existingStart = new Date(reservation.startTime);
                const existingEnd = new Date(reservation.endTime);
                
                // Check for time overlap
                if ((newStart >= existingStart && newStart < existingEnd) ||
                    (newEnd > existingStart && newEnd <= existingEnd) ||
                    (newStart <= existingStart && newEnd >= existingEnd)) {
                    return true; // Conflict found
                }
            }
        }
        
        return false; // No conflicts
    } catch (error) {
        console.error('Error checking reservation conflicts:', error);
        return false; // Assume no conflict if there's an error
    }
}


    async function loadDropdowns() {
        // Load Citizens, Spots, Lots, Sensors
        const [cit, spots, lots, sensors] = await Promise.all([
            fetch(`${API_PATH}/lists.php?type=citizens`).then(r=>r.json()),
            fetch(`${API_PATH}/lists.php?type=spots`).then(r=>r.json()),
            fetch(`${API_PATH}/lists.php?type=lots`).then(r=>r.json()),
            fetch(`${API_PATH}/lists.php?type=sensors`).then(r=>r.json())
        ]);
        
        // Populate Reservation Modals
        const citHTML = cit.map(c => `<option value="${c.citizenID}">${c.fname} ${c.lname}</option>`).join('');
        document.getElementById('addResCitizen').innerHTML = citHTML;
        document.getElementById('editResCitizen').innerHTML = citHTML;

        const spotHTML = spots.map(s => `<option value="${s.spotID}">Spot ${s.spotID}</option>`).join('');
        document.getElementById('addResSpot').innerHTML = spotHTML;
        document.getElementById('editResSpot').innerHTML = spotHTML;

        // Populate Spot Modals
        const lotHTML = lots.map(l => `<option value="${l.lotID}">${l.road} (${l.area})</option>`).join('');
        document.getElementById('addSpotLot').innerHTML = lotHTML;
        document.getElementById('editSpotLot').innerHTML = lotHTML;

        const senHTML = sensors.map(s => `<option value="${s.sensorID}">Sensor ${s.sensorID}</option>`).join('');
        document.getElementById('addSpotSensor').innerHTML = senHTML;
        document.getElementById('editSpotSensor').innerHTML = senHTML;
    }

   async function loadChart() {
    try {
        const res = await fetch(`${API_PATH}/chart.php`);
        const response = await res.json();
        
        console.log('Chart API response:', response);
        
        if (response.error) {
            console.error('Chart API error:', response.error);
            document.getElementById('parkingChart').parentElement.innerHTML = 
                `<div class="alert alert-warning">Chart data unavailable: ${response.error}</div>`;
            return;
        }
        
        // Handle the new response format
        const chartData = response.data || [];
        
        if (!chartData || chartData.length === 0) {
            console.log('No chart data available');
            
            // Check if we have debug info
            if (response.debug) {
                console.log('Debug info:', response.debug);
            }
            
            document.getElementById('parkingChart').parentElement.innerHTML = 
                `<div class="alert alert-info">
                    No revenue data available. This could be because:
                    <ul class="mb-0 mt-2">
                        <li>No reservations have been confirmed yet (status: Reserved)</li>
                        <li>Confirmed reservations don't have amounts set</li>
                        <li>There are no reservations in the system</li>
                    </ul>
                </div>`;
            return;
        }
        
        if(window.myChart) window.myChart.destroy();
        
        // Extract data for chart
        const weekLabels = chartData.map(d => d.week_label || `Week ${d.week_number}`);
        const revenueData = chartData.map(d => parseFloat(d.total_revenue) || 0);
        
        console.log('Week labels:', weekLabels);
        console.log('Revenue data:', revenueData);
        
        window.myChart = new Chart(document.getElementById('parkingChart'), {
            type: 'line',
            data: {
                labels: weekLabels,
                datasets: [{ 
                    label: 'Weekly Revenue ($)', 
                    data: revenueData, 
                    borderColor: '#3498db', 
                    backgroundColor: 'rgba(52, 152, 219, 0.1)',
                    borderWidth: 2,
                    fill: true,
                    tension: 0.3 
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: true,
                        position: 'top',
                        labels: {
                            font: {
                                size: 14
                            }
                        }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return `Revenue: $${context.parsed.y.toFixed(2)}`;
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Revenue ($)',
                            font: {
                                size: 14,
                                weight: 'bold'
                            }
                        },
                        ticks: {
                            callback: function(value) {
                                return '$' + value;
                            }
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: 'Week',
                            font: {
                                size: 14,
                                weight: 'bold'
                            }
                        },
                        ticks: {
                            maxRotation: 45,
                            minRotation: 0
                        }
                    }
                }
            }
        });
        
    } catch (error) {
        console.error('Error loading chart:', error);
        document.getElementById('parkingChart').parentElement.innerHTML = 
            `<div class="alert alert-danger">Error loading chart: ${error.message}</div>`;
    }
}

</script>
</body>
</html>